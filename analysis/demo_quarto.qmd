---
title: "Estimating the Population of Municipalities with MBTA Commuter Rail Stations"
author: "Steven Andrews"
date: 2023-04-24
format:
  html:
    toc: true
    embed-resources: true
editor: visual
---

## The Goal

The goal of this analysis is to find the population of municipalities in Massachusetts that contain a MBTA commuter rail station.

A few semantics if you're new to R.

-   `<-` is the way to say "this is the new name for all the stuff that follows. You may see `=` to do the same thing, although in R we typically use `<-` for assigning variables.
-   `|>` is a"pipe". It lets an author "chain" together commands. It can basically be read as Take this "and then" do this "and then" do that. You may also see the older pipe `%>%` if you happen upon other R code.
-   A name 'scales' followed by "::" and a function means use the function from the preceding library. (For example, `scales::comma`). It's not needed if you called the libraries, but it's nice to see when you're learning what functions live in what packages.

These are dplyr verbs that describe how to manipulate data frames (basically tables).

-   `mutate` means create a new column
-   `summarize` means to collapse similar values across rows
-   `group_by` denotes the groups that should be collapsed
-   `filter` chooses certain rows
-   `select` chooses certain columns

Check out the full repo here: <https://github.com/CTPSSTAFF/MBTA_CR_muni_population>

## Step 0: Initialize Packages

Our first step in most analyses is to load our packages--collections of scripts and functions generated by other people that we can use to perform our analysis. Here, we lean heavily on the tidyverse (mostly `dplyr` for data manipulation, `tidycensus` for importing census data, `sf` for our geospatial processing, `mapview` for easy map making, and the `scales` package for some basic formatting.

```{r}
#| message: false
#| warning: false
library(tidyverse)
library(tidycensus)
library(sf)
library(scales)
library(mapview)
mapviewOptions(fgb = FALSE)
```

## Step 1: Download Census Population

The `tidycensus` package provides a convenient wrapper around the census API. The package is also (optionally) able to use the `tigris` package to download geometry alongside the data itself.

This package is a very powerful tool for automating and scaling census-based analyses across time and space.

```{r}
#| echo: false
#| results: hide
pop_17_21 <- tidycensus::get_acs(
  geography = "county subdivision",
  state = "MA",
  variables = "B01001_001",
  year = 2021,
  geometry = TRUE
) |> sf::st_transform(26986)
```

::: callout-note
ACS might not be the best source of information in all circumstances. Given that we're very close to the 2020 decennial census and we're interested in population, something that dataset has, it might be a good idea to shift to the census. If we were interested in something that isn't available in the decennial census, say the number of public transit users, we may want to use the ACS to develop information about the characteristics of a place (the percentage), and use the decennial census population of that place as a weight.\
\
This being an example, we move onward with the convenient method that shows how we can use the `tidycensus::moe_sum` function later on.
:::

## Step 2: Download Commuter Rail Locations

There are many places we can go to download commuter rail locations. In our work, we typically use a [GTFS recap](https://mbta-massdot.opendata.arcgis.com/datasets/gtfs-recap-fall-2020/about) provided on the MBTA Open Data Portal. When we work with GTFS data, the `tidytransit` package is a useful set of tools. The full GTFS files are closely tied to the schedule information we typically use station locations with. For this example, however, we will use a ready-to-go "[Commuter Rail Stations](https://mbta-massdot.opendata.arcgis.com/datasets/commuter-rail-stations/explore)" dataset from the open data portal.

```{r}
#| message: false
#| warning: false
cr_stations <-
  sf::read_sf(
    "https://gis.massdot.state.ma.us/arcgis/rest/services/Multimodal/GTFS_Systemwide/MapServer/2/query?outFields=*&where=1%3D1&f=geojson"
  ) |>
  select(stop_id, stop_name, zone_id) |> 
  sf::st_transform(26986)
```

## Step 3: Identify Which Town Each Station Is In

We now have municipalities and stations. At this point, we can perform a simple intersection, attaching the town information to each station. The `sf` package provides this geospatial functionality to the R world.

The function provides a helpful reminder that there is an implicit assumption we should be aware of going on. In this case, we are okay with the assumption.

```{r}
#| error: false
cr_stations_ma <- sf::st_intersection(cr_stations, pop_17_21)
```

## Step 4: Filter Our Towns For Those With Commuter Rail Stations

In this step we use some basic filtering to select only municipalities that show up in our commuter rail list. This step can be accomplished in many ways--in fact there are several ways to do this whole thing!

```{r}
pop_17_21_CR <- pop_17_21 |> 
  filter(GEOID %in% cr_stations_ma$GEOID)
```

## Step 5: Add Up The Population

As we approach the end, we use the tools built into `dplyr` alongside the `sf` and `tidycensus` package to sum our values. We use functions built into the `tidycensus` package to sum together margins of error using methods suggested by the Census Bureau itself.

```{r}
pop_17_21_CR_tot <- pop_17_21_CR |>
  summarize(
    pop_total = sum(estimate),
    pop_moe = tidycensus::moe_sum(moe = moe, estimate = estimate)
  ) |> 
  mutate(pop_tot_moe_fmt = paste0(
    scales::comma(pop_total, accuracy = 1), " +/- ", 
    scales::comma(pop_moe, accuracy = 0.1)))
```

We now know that the 2017-2021 ACS data suggests there are `r pop_17_21_CR_tot$pop_tot_moe_fmt` people living in Massachusetts municipalities with MBTA commuter rail stations.

## Step 6: Map The Results

In the last step we use the [leaflet](https://leafletjs.com/) convenience package `mapview` to make a quick interactive map. Another package, `leaflet` provides much more functionality, but is much less convenient for quick maps.

```{r}
mapview(pop_17_21_CR, zcol = "estimate") +
  mapview(cr_stations_ma, col.regions = "purple")
```

## Step 7: Using SF for Grouping

In Step 5, we performed a "summarize" operation. This also used `sf` to summarize the geometry as well:

```{r}
mapview(pop_17_21_CR_tot)
```

Such functionality can be useful if you wanted to aggregate by county or perhaps by Commuter Rail Zone.

```{r}
#| warning: false
#| message: false
# For each muni, let's find the list of zones. 
# If a muni has two zones, let's find the highest zone.

# Split the zones up for easier processing. Call the CapeFlyer services "10". 
cr_stations_zn_ma <- cr_stations_ma |> 
  separate(zone_id, into = c("mode", "zn", "zone")) |> 
  mutate(zone_num = case_when(
    zone == "1A" ~ 0,
    zone == "hyannis" ~ 10,
    zone == "buzzards" ~ 10,
    TRUE ~ as.numeric(zone)
  ))

# Find the max zone.
cr_max_zone <- cr_stations_zn_ma |> 
  group_by(GEOID) |> 
  summarize(zone_mx = max(zone_num))

# Join in the zone to the muni dataset.
pop_17_21_CR <- left_join(
  pop_17_21_CR,
  cr_max_zone |> st_drop_geometry(),
  by = "GEOID")

# Perform the same summary as Step 5.
pop_17_21_CR_zone_tot <- pop_17_21_CR |>
  group_by(zone_mx) |> 
  summarize(
    pop_total = sum(estimate),
    pop_moe = tidycensus::moe_sum(moe = moe, estimate = estimate)
  ) |> 
  mutate(pop_tot_moe_fmt = paste0(
    scales::comma(pop_total, accuracy = 1), " +/- ", 
    scales::comma(pop_moe, accuracy = 0.1)))
```

This map now shows the "rings" around Boston (which looks strange because we choose the max zone of "2" rather than the more common zone of "1A" (transformed into "0").

```{r}
mapview(pop_17_21_CR_zone_tot, zcol = "zone_mx")
```

```{r}
gt::gt(pop_17_21_CR_zone_tot |> 
         st_drop_geometry() |> 
         select(zone_mx,pop_total, pop_moe, pop_and_moe = pop_tot_moe_fmt)) |>
         gt::fmt_number(2, decimals = 0) |> 
         gt::fmt_number(3, decimals = 1)
```
